import pandas as pd
import numpy as np
import joblib
import keras
from meteo import daily_weather_summary
from event_encoder import apply_masking_logic, sum_axis


def get_lag_features(df: pd.DataFrame, date: pd.Timestamp) -> pd.DataFrame:
    """Returns DataFrame with needed lag features"""
    # simple lags
    ids = df.index[df["day"] == date]

    for lag in [7, 14, 21, 28]:
        df.loc[ids, f"lag_{lag}"] = df.loc[
            df["day"] == date - pd.Timedelta(days=lag), "intensity"
        ].values

    # derivatives
    df.loc[ids, "dt_7_w1"] = (df.loc[ids, "lag_7"] - df.loc[ids, "lag_14"]) / 7
    df.loc[ids, "dt_7_w2"] = (df.loc[ids, "lag_14"] - df.loc[ids, "lag_21"]) / 7

    return df


def extend_df(
    df: pd.DataFrame, last_date: pd.Timestamp, date: pd.Timestamp
) -> pd.DataFrame:
    """Extends the DataFrame's days until the specified date"""
    dates = pd.date_range(start=last_date + pd.Timedelta(days=1), end=date, freq="D")

    # cartesian product
    index_product = pd.MultiIndex.from_product(
        [dates, df["barri"].unique()], names=["day", "barri"]
    )
    # create and add new rows
    new_rows = pd.DataFrame(index=index_product).reset_index()
    df = pd.concat([df, new_rows], ignore_index=True).sort_values(["day", "barri"])

    return df


def add_weather_features(
    df: pd.DataFrame, last_date: pd.Timestamp, date: pd.Timestamp
) -> pd.DataFrame:
    """Returns DataFrame with added weather features (self-explanatory)"""
    # get weather for days
    start_string = (last_date + pd.Timedelta(days=1)).strftime("%Y-%m-%d")
    end_string = date.strftime("%Y-%m-%d")

    weather_df = daily_weather_summary(start=start_string, end=end_string)
    weather_df["day"] = pd.to_datetime(weather_df["day"])
    df = df.merge(weather_df, on="day", how="left")

    # renaming
    df["temperature_2m_max"] = df["temperature_2m_max (°C)"]
    df["temperature_2m_min"] = df["temperature_2m_min (°C)"]
    df["precipitation_sum"] = df["precipitation_sum (mm)"]

    df.drop(
        inplace=True,
        columns=[
            "precipitation_sum (mm)",
            "temperature_2m_min (°C)",
            "temperature_2m_max (°C)",
        ],
    )

    return df


def add_event_encodings(df: pd.DataFrame, last_date: pd.Timestamp) -> pd.DataFrame:
    """Returns DataFrame with added events (self-explanatory)"""
    # TODO: actually add event data
    # load encoder and data
    encoder = keras.models.load_model("data/encoder.keras")
    encoder_max_len = 0
    with open("data/encoder_data.txt") as encoder_data_file:
        encoder_max_len = int(encoder_data_file.read())

    # predict no events (need bias)
    zero_prediction = encoder.predict(
        x={
            "input_event": np.zeros((1, encoder_max_len), dtype="int32"),
            "input_impact": np.zeros((1, encoder_max_len, 1), dtype="int32"),
        },
    )

    # set events
    df.loc[df["day"] > last_date, "enc1"] = zero_prediction[0][0]
    df.loc[df["day"] > last_date, "enc2"] = zero_prediction[0][1]
    df.loc[df["day"] > last_date, "enc3"] = zero_prediction[0][2]
    df.loc[df["day"] > last_date, "enc4"] = zero_prediction[0][3]
    df.loc[df["day"] > last_date, "enc5"] = zero_prediction[0][4]

    df.loc[df["day"] > last_date, "is_holiday"] = 0

    return df


def add_categorical_features(df: pd.DataFrame) -> pd.DataFrame:
    """Returns categorical month and day of the week"""
    day_int_to_name = {
        0: "Lunes",
        1: "Martes",
        2: "Miércoles",
        3: "Jueves",
        4: "Viernes",
        5: "Sábado",
        6: "Domingo",
    }

    df["month_cat"] = pd.Series([str(x.month) for x in df["day"]]).astype("category")
    # we use known monday as reference
    df["day_cat"] = pd.Series(
        [
            day_int_to_name[(x - pd.Timestamp(day=4, month=1, year=1982)).days % 7]
            for x in df["day"]
        ]
    ).astype("category")

    df["barri"] = df["barri"].astype("category")

    return df


def fill_data(
    df: pd.DataFrame,
    date: pd.Timestamp,
    features: list[str],
    export_to_csv: bool = True,
) -> pd.DataFrame:
    """Returns DataFrame with data generated by the regressor up until the specified date. Must provide full DataFrame with all information until a certain date, rest of days will be extrapolated"""

    last_date = max(df[df["intensity"].notna()]["day"].unique())

    # add empty days
    df = extend_df(df, last_date, date)

    # add weather features
    df = add_weather_features(df, last_date, date)

    # add event data
    df = add_event_encodings(df, last_date)

    # add categorical features
    df = add_categorical_features(df)

    # get model
    model = joblib.load("data/regressor.joblib")
    while last_date < date:
        # get next date
        next_date = last_date + pd.Timedelta(days=1)

        # add features
        df = get_lag_features(df, next_date)

        # predict
        prediction = np.expm1(
            model.predict((df.loc[(df["day"] == next_date)][features]))
        )

        # assign
        df.loc[(df["day"] == next_date), "intensity"] = prediction

        print("Day " + next_date.strftime("%d-%m-%Y") + " completed")
        last_date = next_date

    if export_to_csv:
        df.to_csv(f"data/data_extended_to_{str(date.strftime('%d-%m-%Y'))}.csv")
    return df


def main():
    pd.set_option("display.max_columns", None)
    df = pd.read_csv("data/final_data.csv")
    df["day"] = pd.to_datetime(df["day"])

    features = [
        "barri",
        "temperature_2m_max",
        "temperature_2m_min",
        "precipitation_sum",
        "is_holiday",
        "month_cat",
        "day_cat",
        "lag_7",
        "lag_14",
        "lag_21",
        "lag_28",
        "dt_7_w1",
        "dt_7_w2",
        "enc1",
        "enc2",
        "enc3",
        "enc4",
        "enc5",
    ]

    fill_data(df, pd.Timestamp(day=4, year=2025, month=9), features)


if __name__ == "__main__":
    main()
